# 方法论（巨重要）
1. 构思->实现->测试
2. 左到右，差错效率递减 最合理的时间是25->15->10;这样的时间安排是最合理的。一定要多思考各种情况
3. 如果说25分钟后还是没有思路，就可以开始看题姐了。

![[Pasted image 20240121215149.png]]


![[Pasted image 20240121221309.png]]
# 题目类型分类经验
## 双指针
原地，一次遍历
### 快慢指针
### 左右指针
数组有固定的顺序，用左右指针很好用

## 小技巧
```cpp
用来指向有序队列中的重复元素的第一个
while(i>0&&nums[i]==nums[i-1]){
                i++;
            }

4 2 2 2 2 1 1
  ｜。    ｜
指向这两个
```

怎么避免这种过界的错误:
凡事要移动指针或者索引的，都要加一条判断，必须是在索引的范围内。
最后再一条条的去减少

## 动态规划：
### 关键1:理解题意
无须多言
### 关键2：如何定义子问题
子问题应该事从前到后的问题，其实也是还是很强的逻辑性。可以用图论的方式来表达下逻辑，更好的突出依赖关系。

1. 怎么把子问题定义的清楚：把不确定的因素定下来
	可能要好几重尝试；
2. **有后效性**：问题的描述还有不确定的地方：
	例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：
	子问题 1：经过 −2的连续子数组的最大和是多少；
	子问题 2：经过 1 的连续子数组的最大和是多少；
3. **无后效性**：问题的描述有确定的地方：
	子问题 1：以 −2 结尾的连续子数组的最大和是多少；
	子问题 2：以 1结尾的连续子数组的最大和是多少；
	子问题 3：以 −3 结尾的连续子数组的最大和是多少；
4. 有后效性转移道无后效性：解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。
### 关键3:状态转移方程：
需要经常思考 **为什么想到需要这样定义*状态***
解决动态规划需要每个字问题只需要求解一次；以后求解问题不会修改之前求解的字问题的结果。
如果说之前的阶段求解的字问题的结果包含不确定的信息，导致后面的字问题无法得到。
#### 定义状态（定义子问题）

`dp[i]`：表示以 `nums[i]` **结尾** 的 **连续** 子数组的最大和。

**说明**：「结尾」和「连续」是关键字。
#### 状态转移方程（描述子问题之间的联系）

	#### 最后：优化空间：这个暂时不关心

###  细节1:初始化



# 易错点
1. 逻辑判断句容易判断的少情况。适当的时候要重构整个设计
2. 今天要注意出错的点了

1. 跳到重复的第一个；跳过之后所有重复的值
2. 逻辑判断考虑三个点：中间的值是否满足，第一个值是否满足，最后一个值是否满足，
3. 对每个小逻辑要多加思考验证
```
if (i >0 && nums[i] == nums[i-1]) {
                continue;
            }
和 
while(i >0 && nums[i] == nums[i-1]) {
                continue;
            }
            后者如果进入循环会一直在循环中
```
# 问题汇总：
数据结构来判断 **是否有重复的字符**，常用的数据结构为哈希集合（即 `C++` 中的 `std::unordered_set`，

1. 怎么比较是同构还是异构？
		最简单办法就是用umap/uset来进行比较。要么就两个循环
 2. 前缀和还能解决什么样的问题？
	 1. 前缀和是什么？前缀和是计算从0-i的和，放到一个hash_map中去，第二个值可以有不同的作用
3. 正常的优化思路事从暴力便利到优化其中一部分的数据结构
5. 二维数组初始化std::vector<std::vector<int>> matrix(6, std::vector<int>(6, 0));
 6. dp[i][j]:
	 1. dp[i]:是一个vector
	 2. dp[i][j]是一个int
O(n)
1. 滑动窗口，两个指针各只走一遍:连续子数组
2. 前缀数组和：便利一遍的同时，将前缀数组存放到hash表中，实际上可以做更多事，比如将前缀数组换成更复杂的数据。或者将int转换成pair等更加复杂的数


